use ::std::str::FromStr;

use crate::ast::{Expr, Op};

grammar;

match {
    // Turn newlines into a token (they are skipped by default)
    r"(\r\n|\n|\r)(\s|\r|\n)?" => END,
} else {
    // Match string literals
    r#"("[^"]*"|([^"]*\\")*)"# => STR,
} else {
    // Ignore any other whitespace (except newlines above)
    r"\s+" => { },
} else {
    _
}

//pub RealExprs = Commas<RealExpr>;

pub RealExprs = Commas<RealExpr>;

RealExpr: Box<Expr<f64>> = {
    AddSub<Real> => <>,
};

AddSub<T>: Box<Expr<T>> = {
    <l:AddSub<T>> <op:"+"> <r:MulDiv<T>> => Box::new(Expr::Bin { op: Op::Add, left: l, right: r }),
    <l:AddSub<T>> <op:"-"> <r:MulDiv<T>> => Box::new(Expr::Bin { op: Op::Sub, left: l, right: r }),
    MulDiv<T>,
};

MulDiv<T>: Box<Expr<T>> = {
    <l:MulDiv<T>> <op:"*"> <r:Unary<T>> => Box::new(Expr::Bin { op: Op::Mul, left: l, right: r }),
    <l:MulDiv<T>> <op:"/"> <r:Unary<T>> => Box::new(Expr::Bin { op: Op::Div, left: l, right: r }),
    Unary<T>
};

Unary<T>: Box<Expr<T>> = {
    <op:"-"> <t:Unary<T>> => Box::new(Expr::Uni { op: Op::Sub, target: t} ),
    <v:T> => Box::new(Expr::Val(v)),
};

Commas<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Lines<T>: Vec<T> = {
    <mut v:(<T> END+)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Blocks<T>: Vec<T> = {
    <mut v:(<T> END "[ \t]*" END)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};


Int: i64 = {
    r"-[0-9]+" => <>.parse::<i64>().unwrap(),
    Uint => <> as i64,
}

Uint: u64 = {
    r"[0-9]+" => <>.parse::<u64>().unwrap(),
}

Real: f64 = {
    Int => <> as f64,
    r"-?[0-9]+\.[0-9]+" => <>.parse::<f64>().unwrap(),
}

Str: String = {
    STR => <>.to_owned(),
}

Chrs: Vec<char> = {
    STR => <>.chars().collect::<Vec<char>>()
};

//Comma<T>: Vec<T> = { // (1)
//    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
//        None => v,
//        Some(e) => {
//            v.push(e);
//            v
//        }
//    }
//};
