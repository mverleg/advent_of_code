use ::std::str::FromStr;

use crate::ast::{Expr, Op};

grammar;

match {
    // Turn newlines into a token (they are skipped by default)
    r"(\r\n|\n|\r)(\s|\r|\n)?" => END,
} else {
    // Match string literals
    r#"("[^"]*"|([^"]*\\")*)"# => STR,
} else {
    // Ignore any other whitespace (except newlines above)
    r"\s+" => { },
} else {
    _
}

pub IntExpr: Box<Expr<i64>> = {
    AddSub<Int> => <>,
};

pub UintExpr: Box<Expr<u64>> = {
    AddSub<Uint> => <>,
};

pub RealExpr: Box<Expr<f64>> = {
    AddSub<Doubl> => <>,
};

AddSub<T>: Box<Expr<T>> = {
    <l:AddSub<T>> <op:"+"> <r:MulDiv<T>> => Box::new(Expr::Bin { op: Op::Add, left: l, right: r }),
    <l:AddSub<T>> <op:"-"> <r:MulDiv<T>> => Box::new(Expr::Bin { op: Op::Sub, left: l, right: r }),
    MulDiv<T>,
};

MulDiv<T>: Box<Expr<T>> = {
    <l:MulDiv<T>> <op:"*"> <r:Unary<T>> => Box::new(Expr::Bin { op: Op::Mul, left: l, right: r }),
    <l:MulDiv<T>> <op:"/"> <r:Unary<T>> => Box::new(Expr::Bin { op: Op::Div, left: l, right: r }),
    Unary<T>
};

Unary<T>: Box<Expr<T>> = {
    <op:"-"> <t:Unary<T>> => Box::new(Expr::Uni { op: Op::Sub, target: t} ),
};

Int: i64 = {
    "-?[0-9]+" => <>.parse::<i64>().unwrap(),
}

Uint: u64 = {
    "[0-9]+" => <>.parse::<u64>().unwrap(),
}

Doubl: f64 = {
    "[0-9]+" => <>.parse::<u64>().unwrap() as f64,
    "[0-9]+.[0-9]+" => <>.parse::<f64>().unwrap(),
}

//Comma<T>: Vec<T> = { // (1)
//    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
//        None => v,
//        Some(e) => {
//            v.push(e);
//            v
//        }
//    }
//};
